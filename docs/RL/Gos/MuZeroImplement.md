# MuZero
## Ideas
* Learn a model(MDP) and corresponding value/policy networks. It is an end-to-end algorithm.
* A representing network has been learned to encode raw observations.  
* Model of transition and reward is learned based on representation network output.  
* The model learned is not for original observation decoding. It is to make value/policy network a better one.
* Representation is based on a sequence of observation. It is for both Attention and Recurrent states.
* It uniformed learning on illegal actions and terminal actions.
* It is prospecting in real-world-environment problem learning and partially observation problem learning.
## Training
### Data Collection
![eva_sequence](./images/muzero_eva.jpg)
#### Details
∑ τ α π δ γ ∏ Δ Λ μ ∈ ∀ β λ ∞ η θ ∝ σ

##### pUTC
In expanded children selection, the rule is:

a<sup>k</sup> = argmax[Q(s,a) + P(s,a) * ((∑<sub>b</sub>N(s,b))<sup>1/2</sup> / (1 + N(s,a))) * (c<sub>1</sub> + log((∑<sub>b</sub>N(s,b) + c<sub>2</sub> + 1) / c<sub>2</sub>))]
* Both Q and P weight. Either one of them seemed prospecting, the action deserves more trials.
* Q is an unknown scalar, while 0 <= P <= 1, so P has to be adjusted to match the range of Q to impact its effect.
* If N(s,a) is relatively small, it deserves more exploration.
* It is in fact the c<sub>1</sub> that dominates the scale of P part.
* log((∑<sub>b</sub>N(s,b) + c<sub>2</sub> + 1) / c<sub>2</sub>) = log(∑<sub>b</sub>N(s,b) / c<sub>2</sub> + 1 + 1 / c<sub>2</sub>) > 0. The larger ∑<sub>b</sub>N(s,b) is, the more times that S has been visited, the more believable P is. 
##### Dirichlet Noise
* Sum of P is still 1 after adding the noise
* It has no favor to any particular choice
##### TD(lambda)
In Q update in backup phase, the Q is a TD(λ) summary:

G<sup>k</sup> = ∑<sub>τ=[0:l-1-k]</sub>γ<sup>τ</sup>r<sub>k+1+τ</sub> + γ<sup>l-k</sup>v<sup>l</sup>

QSum(s<sup>k-1</sup>,a<sup>k</sup>) += G<sup>k</sup>

N(s<sup>k-1</sup>,a<sup>k</sup>) += 1

Q(s<sup>k-1</sup>,a<sup>k</sup>) := QSum(s<sup>k-1</sup>,a<sup>k</sup>) / N(s<sup>k-1</sup>,a<sup>k</sup>)
##### Temperature
The estimation of π is based on N<sup>1/T</sup> instead of pure N. 

Pa = N(a)<sup>1/T</sup> / ∑<sub>b</sub>N(b)<sup>1/T</sup>

The larger T is, the less greedy and less deterministic π is
### Network Training
There are three networks:
* Representation: Observation --> State
* Dynamics: (Previous States, Previous Action, State, Action)  --> (Reward, NextState)
* Value/Policy: State --> (Policy, Value)

The State generated by either Representation network or Dynamics network is not used to input compression. 
It is not used decode State back into Observation. It is used to extract features that weight in Value/Policy prediction.
So we do not care about loss between raw Observation and State. Then the loss function is:

l<sub>t</sub>(θ) = ∑<sub>k=[0:K]</sub>L<sup>r</sup>(u<sub>t+k</sub>, r<sub>t</sub><sup>k</sup>) + L<sup>v</sup>(z<sub>t+k</sub>, v<sub>t</sub><sup>k</sup>) + L<sup>p</sup>(π<sub>t+k</sub>, p<sub>t</sub><sup>k</sup>) + Reg<sub>l2</sub>: K = unroll steps
#### Target
1. Select a sample t. K = unroll steps
2. [obs<sub>t:t+K</sub>, action<sub>t:t+K</sub>, u<sub>t:t+K</sub>] has been stored in replay buffer in *Data Collection* phase.
3. Get z<sub>t</sub> = ∑<sub>i=t:t+K-1</sub>u<sub>i</sub>γ<sup>i</sup> + v<sub>t+K</sub>. v<sub>t+K</sub>γ<sup>K</sup> is looked up from transition and reward table that calculated in *Data Collection* phase
4. u<sub>t</sub> has been collected in *Data Collection* Phase
5. π<sub>t</sub> := ratio of visit count collected in *Data Collection* Phase
#### Output
![output](./images/muzero_output.jpg)
### Reanalysis
MuZero Reanalyze revisits its past time-steps and re-executes its search using the latest model parameters.
That is, select samples (Obs<sub>t</sub>, Reward<sub>t</sub>, Action<sub>t</sub>) and its rollout steps (Obs<sub>t+i</sub>, Reward<sub>t+i</sub>, Action<sub>t+i</sub>: i=0...K) from replay buffer,
then re-calculate their network outputs and re-estimate their corresponding target values. 
For target values:
* Reward (u) remains untouched as there is no real re-play in real environment.
* Value (z) has been re-calculated where truncated v<sub>t+K</sub> has been replaced by network with current parameters
* Policy (π) has been re-calculated by same algorithm that executed in *Data Collection*, but with updated networks. 
  And each input of time step t (Obs<sub>t+i</sub>) has been calculated end-to-end independently. That is, sequence of obs<sub>t+i</sub>
  --> state<sub>t+i</sub> --> MCTS search<sub>t+i</sub> --> target policy output<sub>t+i</sub>.
  
It is obvious an off-policy training as:
1. Value(s) has been calculated by updated network
2. The rollout steps have not been generated by current policy, they are in episodes that had been conducted by networks that are different from current ones.
If the part of an episode start with Obs<sub>t</sub> happened with instruction of current network(θ), 
the Obs<sub>t+1</sub>, Obs<sub>t+2</sub> ... may be far away from that extracted from replay buffer. 
That introduced extra loss as:   
    * The algorithm trains dynamic network indirectly by policy/value loss
    * The algorithm considers prediction of both one step and multi-step
    
But guess that it still deserves as:
1. It is data efficient
2. There is a hidden policy called rollout policy. It may be good to rollout-policy training. 
3. Rollout policy is of less importance. Rollout often helps whatever the policy is.
4. It is to avoid overfitting.
### Difference to RNN
It is not complicated Recurrent state-space model (RSSM).
It is simpler than LSTM/GRU.
It is just a simple recurrent process. 
## Reference
* [Dirichlet noise](https://stats.stackexchange.com/questions/322831/purpose-of-dirichlet-noise-in-the-alphazero-paper)
* [Julian Schrittwieser](https://www.youtube.com/watch?v=L0A86LmH7Yw)
* [MuZero Rollout](https://www.youtube.com/watch?v=dFzFGn87wGM)
* [MuZero-Pytorch](https://github.com/koulanurag/muzero-pytorch.git)
* [Introduction by Sutton](https://www.andrew.cmu.edu/course/10-703/textbook/BartoSutton.pdf)
* [UPenn CIS 522 Guest Lecture | April 2020](https://www.seas.upenn.edu/~cis522/slides/CIS522_Lecture12T.pdf)